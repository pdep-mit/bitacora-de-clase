# Cierre de la materia

Estuvimos viendo algunos ejercicios de final como para refrescar un poco los conceptos de los paradigmas que vimos en la primer parte de la materia, y en caso de no promocionar la materia también tener una noción de qué esperar. Los finales son teórico prácticos con un foco fuerte en los conceptos, tanto particulares de cada paradigma como [transversales](http://wiki.uqbar.org/wiki/articles/paradigmas-de-programacion.html),
(que no son propios de un paradigma de programación sino que son conceptos de programación en general).

Una linda forma de cerrar la materia es [volver al principio](https://github.com/pdep-mit/bitacora-de-clase/blob/master/clase-01.md).
Ahora que ya vimos todo lo que teníamos planeado podemos mirar para atrás, recordar de dónde venimos y cómo cambió nuestra forma de entender qué es programar luego de este trayecto.

Respecto a lo que cada paradigma propone como factor diferencial de los otros, algo interesante para llevarse es, no sólo entender cómo esos conceptos nos ayudan a resolver problemas en un lenguaje basado en ese paradigma, sino también entender que la mayoría de los lenguajes industriales no se limitan a soportar un único paradigma de la forma más pura posible. Lo más valioso que se pueden llevar de esta materia no es cada paradigma de forma aislada, sino los conceptos sobre los que se basa cada uno de ellos y la motivación detrás.

Si son capaces de llevarse esas ideas y aplicarlas en otros contextos, por ejemplo en lenguajes que toman ideas de varios paradigmas, y luego aprovechan todas las herramientas disponibles y eligen activamente cuáles usar para llegar a 
soluciones más interesantes, que sean más fáciles de mantener en el tiempo, y en general, que los hagan más felices... 
ahí realmente podremos decir que entendieron todo.

Recuerden que como futuros ingenieros es su responsabilidad ser capaces de elegir qué herramienta usar cuando hay más de una disponible. Y en el área de desarrollo de software, la variedad de herramientas es enorme.

## Próximos pasos

Dentro del [plan de la carrera](http://www.sistemas.frba.utn.edu.ar/index.php/academico/plan-k08) hay varias materias que (sean o no correlativas) están relacionadas con lo que estuvimos viendo a lo largo del año. 
La más directa es Diseño de Sistemas, la troncal de 3er año.

También, si les gustó esta materia y quieren levelear en cuestiones de programación, les recomendamos cursar la electiva 
[Técnicas Avanzadas de Programación](http://tadp-utn-frba.github.io/contenidos/).

Luego hay varias otras materias cuya práctica implica programar (yay!!), que capaz las sienten un poco más lejanas, sin embargo les podemos asegurar que lo que vimos les va a servir en la medida en que intenten aprovechar esas herramientas. 
Recuerden los conceptos transversales: las **buenas abstracciones** son aliadas, 
entender **cuándo queremos producir efecto y cuándo no** es clave, y buscar cómo aprovechar conceptos como 
**orden superior** en otros lenguajes (incluso C) en pos de llegar a soluciones **más declarativas**,
bien podrían ser factores cruciales que diferencian un programa que anda (con suerte) de uno que se sostiene 
y con el que realmente se sienten cómodos.

Acuérdense también de las herramientas de versionado y de testing automático que usamos, y traten de incorporar también más herramientas para el día a día.
Los entornos de desarrollo tienen features que no les mostramos, no porque no sirvan o sean demasiado complejos, sino sólo por cuestiones de tiempo en mayor medida.
Empiecen a investigar el potencial de los IDEs, por ejemplo, en materia de refactors automáticos y debugging.

Cada herramienta que incorporen hace que crezcan como profesionales. Aprovechen para incorporarlas temprano, así no sufren innecesariamente :smile:

En fin, esto recién está empezando. Disfruten el viaje.
